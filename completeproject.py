# -*- coding: utf-8 -*-
"""CompleteProject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lPSqSQWA5u3WM9JKyWiMsKkGnWFdQAd3
"""

import tensorflow as tf

import pandas as pd
import numpy as np
import random as python_random
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
import time
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score
from tensorflow.keras.optimizers import Adam

# For LSTM model
from tensorflow import keras
#from keras.models import Sequential
#from keras.layers import Dense
#from keras.layers import LSTM
#from keras.layers import Dropout
from tensorflow.keras import Sequential,layers,callbacks
from tensorflow.keras.layers import Dense,LSTM,Dropout,GRU,Bidirectional
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.models import load_model
from openpyxl import load_workbook

cd 'drive/MyDrive/Colab Notebooks'

from google.colab import drive
drive.mount('/content/drive')



python_random.seed(123)

from numpy.random import seed
seed(123)

tf.random.set_seed(1234)

#df = pd.read_csv('df1.csv')
df = pd.read_csv('Temp_SM.csv')
#X = df.iloc[:, :-1].values
#y = df.iloc[:, -1].values
#y = np.reshape(-1, 1)

X = df
y = df.loc[:,['Tdrop']]
X_test = X[5921:8235]
y_test = y[5921:8235]
X_train= X[0:5920]
y_train =y[0:5920]

# Scale features
s1 = MinMaxScaler(feature_range =(-1, 1))
#Xs = s1.fit_transform(df[['Tair', 'RH', 'Vel', 'Size', 'Tsec', 'L', 'P', 'F', 'Tdrop']])
Xs = s1.fit_transform(X_train)
#Xs = s1.fit_transform(df(X)) alternative representation
#Scale predicted value
s2 = MinMaxScaler(feature_range=(-1, 1))
#Ys = s2.fit_transform(df[['Tdrop']])
Ys = s2.fit_transform(y_train)
#Ys = s2.fit_transform(df(y)) alternative representation

def layer1(shape1,shape2,j):
    model = Sequential()
    model.add(LSTM(units=j, return_sequences=True, \
          input_shape=(shape1,shape2)))
    model.add(Dropout(0.2))
    model.add(LSTM(units=j))
    model.add(Dropout(0.2))
    model.add(Dense(units=1))

    model.compile(optimizer = 'adam', loss = 'mean_squared_error',\
              metrics = ['accuracy'])


    return model

def layer2(shape1,shape2,j):
    model = Sequential()
    model.add(LSTM(units=j, return_sequences=True, \
          input_shape=(shape1,shape2)))
    model.add(Dropout(0.2))
    model.add(LSTM(units=j, return_sequences=True))
    model.add(Dropout(0.2))
    model.add(LSTM(units=j))
    model.add(Dropout(0.2))
    model.add(Dense(units=1))

    model.compile(optimizer = 'adam', loss = 'mean_squared_error',\
              metrics = ['accuracy'])


    return model

def layer3(shape1,shape2,j):
    model = Sequential()
    model.add(LSTM(units=j,return_sequences=True, \
          input_shape=(shape1,shape2)))
    model.add(Dropout(0.2))
    model.add(LSTM(units=j,return_sequences=True))
    model.add(Dropout(0.2))
    model.add(LSTM(units=j,return_sequences=True))
    model.add(Dropout(0.2))
    model.add(LSTM(units=j))
    model.add(Dropout(0.2))
    model.add(Dense(units=1))
    model.compile(optimizer = 'adam', loss = 'mean_squared_error',\
              metrics = ['accuracy'])



    return model

def layer4(shape1,shape2,j):
    model = Sequential()
    model.add(LSTM(units=j,return_sequences=True, \
          input_shape=(shape1,shape2)))
    model.add(Dropout(0.2))
    model.add(LSTM(units=j,return_sequences=True))
    model.add(Dropout(0.2))
    model.add(LSTM(units=j,return_sequences=True))
    model.add(Dropout(0.2))
    model.add(LSTM(units=j,return_sequences=True))
    model.add(Dropout(0.2))
    model.add(LSTM(units=j))
    model.add(Dropout(0.2))
    model.add(Dense(units=1))
    model.compile(optimizer = 'adam', loss = 'mean_squared_error',\
              metrics = ['accuracy'])



    return model

def layer5(shape1,shape2,j):
    model = Sequential()
    model.add(LSTM(units=j,return_sequences=True, \
          input_shape=(shape1,shape2)))
    model.add(Dropout(0.2))
    model.add(LSTM(units=j,return_sequences=True))
    model.add(Dropout(0.2))
    model.add(LSTM(units=j,return_sequences=True))
    model.add(Dropout(0.2))
    model.add(LSTM(units=j,return_sequences=True))
    model.add(Dropout(0.2))
    model.add(LSTM(units=j,return_sequences=True))
    model.add(Dropout(0.2))
    model.add(LSTM(units=j))
    model.add(Dropout(0.2))
    model.add(Dense(units=1))
    model.compile(optimizer = 'adam', loss = 'mean_squared_error',\
              metrics = ['accuracy'])



    return model

for window in range(51, 60, 10) :
    #window = 60
    X = []
    Y = []
    for i in range(window,len(Xs)):
        X.append(Xs[i-window:i,:])
        Y.append(Ys[i])

    # Reshape data to format accepted by LSTM
    X, Y = np.array(X), np.array(Y)
    # Reshaping
    #X = np.reshape(X, (X.shape[0], X.shape[1], 9))


    for j in range(28,30,2):
        for k in range (1,6):
            if (k==1):
                model=layer1(X.shape[1],X.shape[2],j)
            elif(k==2):
                model=layer2(X.shape[1],X.shape[2],j)
            elif(k==3):
                model=layer3(X.shape[1],X.shape[2],j)
            elif(k==4):
                model=layer4(X.shape[1],X.shape[2],j)
            else:
                model=layer5(X.shape[1],X.shape[2],j)

    # Allow for early exit
            es = EarlyStopping(monitor='loss',mode='min',verbose=1,patience=10)

    # Fit (and time) LSTM model
            t0 = time.time()
    #history = model.fit(X, Y, epochs=500, validation_split=0.1, verbose=0)
            history = model.fit(X, Y, epochs = 1000, batch_size = 32, callbacks=[es], verbose=1)
            t1 = time.time()
            print('Runtime: %.2f s' %(t1-t0))

    # Plot loss
            plt.figure(figsize=(8,4))
            plt.semilogy(history.history['loss'])
            plt.xlabel('epoch'); plt.ylabel('loss')
            plt.savefig('Tdrop_loss.png')
        #model.save('model.h5')
            HISTORY = history.history['loss']
    # Verify the fit of the model
            Yp = model.predict(X)
            Yp = Yp.reshape((Yp.shape[0],Yp.shape[1]))

    # un-scale outputs
            Yu = s2.inverse_transform(Yp)

            Ym = s2.inverse_transform(Y)

            Xts = s1.transform(X_test)
            Yts = s2.transform(y_test)

            Xti = []
            Yti = []
            for i in range(window,len(Xts)):
                Xti.append(Xts[i-window:i,:])
                Yti.append(Yts[i])

        # Reshape data to format accepted by LSTM
            Xti, Yti = np.array(Xti), np.array(Yti)
        #Xti = np.reshape(Xti, (Xti.shape[0], Xti.shape[1], 9))

        # Verify the fit of the model
            Ytp = model.predict(Xti)
        #Ytp = Ytp.reshape((Ytp.shape[0],Ytp.shape[1]))
        # un-scale outputs
            Ytu = s2.inverse_transform(Ytp)

            Ytm = s2.inverse_transform(Yti)

            plt.figure(figsize=(10,6))
            plt.subplot(2,1,1)
            plt.plot(Ytu,'r-',label='LSTM Predicted')
            plt.plot(Ytm,'k--',label='Measured')
            plt.legend()


            print('The R2 score of the Training set is :\t{:0.3f}'.format(r2_score(Ym, Yu)))
            print('The R2 score of the Testing set is :\t{:0.3f}'.format(r2_score(Ytm, Ytu)))
            R2SCORETRAIN = r2_score(Ym,Yu)
            R2SCORETEST = r2_score(Ytm, Ytu)
            print(k,window,j,R2SCORETRAIN)
            print(k,window,j,R2SCORETEST)


        # Using predicted values to predict next step
            Xtsq = Xts.copy()
            for i in range(window,len(Xtsq)):
                Xin = Xtsq[i-window:i].reshape((1, window, 9))
                Xtsq[i][0] = model.predict(Xin)
                Yti[i-window] = Xtsq[i][0]

            Ytun = (Yti - s2.min_[0])/s2.scale_[0]
            Ytun = s2.inverse_transform(Yti)


        #Plots
            plt.figure(figsize=(10,6))
            plt.subplot(2,1,1)
            plt.plot(Ytun,'r-',label='LSTM Predicted')
            plt.plot(Ytm,'k--',label='Measured')
            plt.legend()

        # calculates and print r_2 score of training and testing
            print('The R2 score of the Training set of  predicted values to predict is :\t{:0.3f}'.format(r2_score(Ym, Yu)))
            print('The R2 score of the Testing set predicted values to predict is :\t{:0.3f}'.format(r2_score(Ytm, Ytun)))
            R2SCORETESTPRE = r2_score(Ytm, Ytun)


            name =str(window)+str(j)+str(k)
            ytu = pd.DataFrame(Ytu,columns=['LSTM Predicted'])
            ytm = pd.DataFrame(Ytm,columns=['Measured'])
            ytun = pd.DataFrame(Ytun,columns=['Predicted to predict'])
            HISTORY1 =pd.DataFrame(HISTORY,columns=['LOSS'])
       # R2_TRAIN = pd.DataFrame(R2SCORETRAIN,columns=['R2SCOETRAIN'])
       # R2_TEST = pd.DataFrame(R2SCORETEST,columns=['R2SCOETEST'])
       # R2_TESTPre = pd.DataFrame(R2SCORETESTPRE,columns=[' R2SCORETESTPRE'])
       # PredictedDF = pd.concat([ytm,ytu,ytun,HISTORY1,R2_TRAIN,R2_TEST,R2_TESTPre], axis=1)
            PredictedDF = pd.concat([ytm,ytu,ytun,HISTORY1],axis=1)


        #PredictedDF.to_excel(r'C:\Users\AKINYEMI\Desktop\500l\Orignal project\SENT\DATA.xlsx', sheet_name = name , index = False)
        #PredictedDF.to_excel(r'C:\Users\AKINYEMI\Desktop\500l\Orignal project\SENT\name.xlsx', sheet_name = name , index = False)
            file_name = name+".xlsx"
            PredictedDF.to_excel(file_name)

        # new dataframe with same columns
            df = pd.DataFrame({'WINDOW': [window],
                               'LAYERS': [k],
                               'NEURON': [j],
                               'R2TRAIN': [R2SCORETRAIN],
                               'R2TEST': [R2SCORETEST],
                               'R2SCORETESTPRE':[R2SCORETESTPRE]})
            writer = pd.ExcelWriter('Tem_SM.xlsx', engine='openpyxl')
        # try to open an existing workbook
            writer.book = load_workbook('Tem_SM.xlsx')
        # copy existing sheets
            writer.sheets = dict((ws.title, ws) for ws in writer.book.worksheets)
        # read existing file
            reader = pd.read_excel(r'Tem_SM.xlsx')
        # write out the new sheet
            df.to_excel(writer,index=False,header=False,startrow=len(reader)+1)

            writer.close()